<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: world.class.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: world.class.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Represents the game world, including the character, enemies, objects, and environment.
 * Handles collision detection, rendering, game state management, and interactions.
 */
class World {
    character = new Character();
    level = level1;
    sun = [new Sun()];
    canvas;
    ctx;
    keyboard;
    camara_x = 0;
    statusBar = new StatusBarHealth();
    statusbarChickenBoss = new StatusbarChickenBoss();
    statusBarBottle = new StatusBarBottle();
    statusBarCoin = new StatusBarCoin();
    totalCoins = this.level.coins.length;
    totalBottles = this.level.bottles.length;
    collectedBottles = 0;
    throwableObjects = [];
    canThrow = true;
    gameState = 'start'; // Startscreen is active
    startScreenImage = new Image();
    showStartScreen = true;

    /**
     * Initializes the world, sets up the canvas, connects the character and keyboard, and starts the game loop.
     * @param {HTMLCanvasElement} canvas - The game's canvas element.
     * @param {Keyboard} keyboard - The keyboard object for player input.
     */
    constructor(canvas, keyboard) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.keyboard = keyboard;
        this.draw();
        this.setWorld();
        this.run();
    }

    /**
     * Connects the character and enemies to the world instance.
     */
    setWorld() {
        this.character.world = this;
        this.level.enimies.forEach(enemy => {
            enemy.world = this;
        });
    }

    /**
     * Runs the main game loop, checking for collisions, game over conditions, and win conditions.
     */
    run() {
        setInterval(() => {
            this.checkCollisions();
            this.checkCollisionsCoin();
            this.checkCollisionsBottle();
            this.checkThrowObjects();
            this.checkGameOver();
            this.checkWin();
        }, 100);
    }

    /**
     * Checks if the game is over (character is dead) and triggers the game over screen.
     */
    checkGameOver() {
        if (this.character.isDead()) {
            if (!document.getElementById('game-over-screen')) {
                stopGame();
                showGameOverScreen();
                changePlayButtonToRestart();
            }
        }
    }

    /**
     * Checks if the player has won (all enemies defeated) and triggers the win screen.
     */
    checkWin() {
        if (this.level.enimies.length === 0 &amp;&amp; !document.getElementById('win-screen')) {
            stopGame();
            showWinScreen();
            changePlayButtonToRestart();
        }
    }

    /**
     * Handles throwing objects (bottles) when the "D" key is pressed.
     */
    checkThrowObjects() {
        if (this.keyboard.D &amp;&amp; this.canThrow &amp;&amp; this.collectedBottles > 0) {
            let bottle = new ThrowableObject(this.character.x + 100, this.character.y + 100);
            this.throwableObjects.push(bottle);
            this.collectedBottles--; 
            this.statusBarBottle.setPercentage(this.calculateBottlePercentage());
            this.canThrow = false; 
        }
    }

    /**
     * Checks for collisions between the character and enemies.
     */
    checkCollisions() {
        if (this.character.isDead()) return;

        this.level.enimies.forEach((enemy) => {
            if (this.character.isColliding(enemy)) {
                if (this.character.isAboveGround() &amp;&amp; this.character.speedY &lt; 0) {
                    enemy.dead();
                    this.character.makeInvincible();
                    this.character.speedY = 15; 
                } else if (!this.character.isInvincible) {
                    this.character.hit();
                    this.statusBar.setPercentage(this.character.energy);
                }
            }
        });
    }

    /**
     * Checks if a thrown bottle hits an enemy and applies damage or destroys the enemy.
     */
    checkBottleCollision() {
        this.throwableObjects.forEach((bottle) => {
            this.level.enimies.forEach((enemy) => {
                if (bottle.isColliding(enemy)) {
                    if (enemy instanceof ChickenBoss) {
                        enemy.hit();
                    } else {
                        enemy.dead();
                    }
                    bottle.break();
                }
            });
        });
    }

    /**
     * Checks if the character collects a coin and updates the status bar.
     */
    checkCollisionsCoin() {
        for (let i = this.level.coins.length - 1; i >= 0; i--) {
            let coin = this.level.coins[i];
            if (this.character.isColliding(coin)) {
                coin.playCoinSound();
                this.level.coins.splice(i, 1);
                this.statusBarCoin.setPercentage(this.calculateCoinPercentage());
            }
        }
    }

    /**
     * Checks if the character collects a bottle and updates the status bar.
     */
    checkCollisionsBottle() {
        for (let i = this.level.bottles.length - 1; i >= 0; i--) {
            if (this.character.isColliding(this.level.bottles[i])) {
                this.level.bottles.splice(i, 1);
                this.collectedBottles++;
                this.statusBarBottle.setPercentage(this.calculateBottlePercentage());
            }
        }
    }

    /**
     * Calculates the percentage of collected coins.
     * @returns {number} The percentage of coins collected.
     */
    calculateCoinPercentage() {
        return Math.min(((this.totalCoins - this.level.coins.length) / this.totalCoins) * 100, 100);
    }

    /**
     * Calculates the percentage of collected bottles.
     * @returns {number} The percentage of bottles collected.
     */
    calculateBottlePercentage() {
        return Math.min((this.collectedBottles / this.totalBottles) * 100, 100);
    }

    /**
     * Draws all objects on the canvas.
     */
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.ctx.translate(this.camara_x, 0); 

        this.sun[0].x = -this.camara_x + 570; 

        this.addObjectsToMap(this.level.backgroundObjects);
        this.addObjectsToMap(this.sun);
        this.addToMap(this.character);
        this.addObjectsToMap(this.level.clouds);
        this.addObjectsToMap(this.level.enimies);
        this.addObjectsToMap(this.level.coins);
        this.addObjectsToMap(this.level.bottles);
        this.addObjectsToMap(this.throwableObjects);
        this.addToMap(this.statusbarChickenBoss);

        this.ctx.translate(-this.camara_x, 0);
        this.addToMap(this.statusBar);
        this.addToMap(this.statusBarBottle);
        this.addToMap(this.statusBarCoin);
        this.ctx.translate(this.camara_x, 0);
        this.ctx.translate(-this.camara_x, 0);

        requestAnimationFrame(() => this.draw());
    }

    /**
     * Adds an object to the canvas.
     * @param {MovableObject} mo - The object to draw.
     */
    addToMap(mo) {
        if (mo.otherDirection) {
            this.flipImage(mo);
        }
        mo.draw(this.ctx);
        mo.drawFrame(this.ctx);
        if (mo.otherDirection) {
            this.flipImageBack(mo);
        }
    }

    /**
     * Adds multiple objects to the canvas.
     * @param {MovableObject[]} objects - The array of objects to draw.
     */
    addObjectsToMap(objects) {
        objects.forEach(o => this.addToMap(o));
    }

    /**
     * Flips an image horizontally.
     * @param {MovableObject} mo - The object to flip.
     */
    flipImage(mo) {
        this.ctx.save();
        this.ctx.translate(mo.width, 0);
        this.ctx.scale(-1, 1);
        mo.x = mo.x * -1;
    }

    /**
     * Restores the original orientation of an image after flipping.
     * @param {MovableObject} mo - The object to restore.
     */
    flipImageBack(mo) {
        mo.x = mo.x * -1;
        this.ctx.restore();
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MovableObject.html">MovableObject</a></li><li><a href="World.html">World</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Mar 01 2025 17:50:50 GMT+0100 (Mitteleurop√§ische Normalzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
